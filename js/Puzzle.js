// Generated by CoffeeScript 2.3.2
var reduce, render_3_partition, set_size,
  modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

render_3_partition = void 0;

reduce = void 0;

set_size = void 0;

JS.require('JS.Set', 'JS.Hash', function(Set, Hash) {
  var Block, EdgeMatch, Jigsaw, JigsawPuzzle, Piece, Polyomino, PolyominoPack, Puzzle, SignedBlock, SignedEdgeMatch, UnsignedBlock, UnsignedEdgeMatch, draw, height, puzzle, puzzle_type, render, set_puzzle_text, set_size_text, size, sum, target_sum_3_partition, width;
  sum = function(nums) {
    return _.reduce(nums, (function(total, num) {
      return num + total;
    }), 0);
  };
  target_sum_3_partition = function(nums) {
    return sum(nums) * 3 / nums.length;
  };
  Piece = (function() {
    class Piece {
      // Basic piece of a puzzle
      constructor(position1) { // [x, y]
        this.position = position1;
      }

      rotate() {}

    };

    
    // Rotation degrees
    Piece.CCW_0 = 0;

    Piece.CCW_90 = 1;

    Piece.CCW_180 = 2;

    Piece.CCW_270 = 3;

    return Piece;

  }).call(this);
  Block = (function() {
    class Block extends Piece {
      // Stores entries in right, top, left, bottom order
      constructor(position, entries1) {
        super(position);
        this.entries = entries1;
      }

      rotate(amount) {
        var i, j, ref, results;
        results = [];
        for (i = j = 0, ref = amount; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          results.push(this.entries.unshift(this.entries.pop()));
        }
        return results;
      }

      static tile_before_drag(e) {
        return this.should_rotate = true;
      }

      static tile_drag_move(e) {
        var x, y;
        this.front();
        [x, y] = [Math.floor(this.x()), Math.floor(this.y())];
        if (x !== this.piece.position[0] || y !== this.piece.position[1]) {
          this.should_rotate = false;
          return this.puzzle.swap_pieces(this.piece.position[0], this.piece.position[1], x, y);
        }
      }

      static tile_drag_end(e) {
        this.x(this.piece.position[0] + 0.5);
        this.y(this.piece.position[1] + 0.5);
        if (this.should_rotate) {
          this.inner.rotate(Math.round((this.inner.transform().rotation - 90) % 360, 0, 0));
          return this.piece.rotate(Piece.CCW_90);
        }
      }

    };

    
    // Entry indices
    Block.RIGHT = 0;

    Block.TOP = 1;

    Block.LEFT = 2;

    Block.BOTTOM = 3;

    
    // SVG
    Block.Tile = SVG.invent({
      create: 'g',
      inherit: SVG.G,
      extend: {
        constructor_: function(entries) {
          this.rect(1, 1).fill('ivory').move(-0.5, -0.5);
          return this;
        }
      },
      construct: {
        block_tile: function(entries) {
          return this.put(new Block.Tile).constructor_(entries);
        }
      }
    });

    
    //@STRIP_COLORS = ['#f00', '#f80', '#840', '#fc0', '#ff0', '#8f0', '#0f0', '#0f8', '#0ff', '#088', '#08f', '#00f', '#80f', '#808', '#f0f', '#f08']
    Block.STRIP_COLORS = ['#f00', '#ff0', '#0f0', '#0ff', '#00f', '#f0f', '#f88', '#880', '#080', '#088', '#88f', '#808', '#000', '#555', '#aaa', '#fff'];

    return Block;

  }).call(this);
  UnsignedBlock = (function() {
    class UnsignedBlock extends Block {
      // Positive integer entries only!
      constructor(position, entries) {
        super(position, entries);
      }

      reduce_signed(u0, u1, u2, u3) { // arguments are unique positive integers
        // Return the 4 signed blocks that can simulate this unsigned one
        return [new SignedBlock([0, 0], [-u1, this.entries[1], -this.entries[2], u2]), new SignedBlock([1, 0], [this.entries[0], -this.entries[1], u1, -u0]), new SignedBlock([0, 1], [u3, -u2, this.entries[2], -this.entries[3]]), new SignedBlock([1, 1], [-this.entries[0], u0, -u3, this.entries[3]])];
      }

    };

    
    // SVG
    UnsignedBlock.Tile = SVG.invent({
      create: 'g',
      inherit: SVG.G,
      extend: {
        constructor_: function(entries) {
          var colors, d, digits, height, i, j, k, l, num, ref;
          this.block_tile(entries);
          colors = ['#000', '#555', '#aaa', '#fff'];
          for (i = j = 0; j < 4; i = ++j) {
            this.polygon([[0.5, -0.5], [0.25, -0.25], [0.25, 0.25], [0.5, 0.5]]).fill(colors[modulo(entries[i], colors.length)]).rotate(-90 * i, 0, 0);
          }
          for (i = k = 0; k < 4; i = ++k) {
            num = entries[i];
            digits = Math.floor(Math.max(0, Math.log2(num)) / 4) + 2; // include initial 0 to prevent digit-splitting cheats like fe -> ffee
            for (d = l = 0, ref = digits; (0 <= ref ? l < ref : l > ref); d = 0 <= ref ? ++l : --l) {
              height = 0.25 * (2 * digits - 1 - 2 * d) / (2 * digits - 1);
              this.polygon([[0.5, -height], [0.25, -height], [0.25, height], [0.5, height]]).fill(Block.STRIP_COLORS[modulo(num, 0x10)]).rotate(-90 * i, 0, 0);
              num = Math.floor(num / 0x10);
            }
          }
          return this;
        }
      },
      construct: {
        ublock_tile: function(entries) {
          return this.put(new UnsignedBlock.Tile).constructor_(entries);
        }
      }
    });

    return UnsignedBlock;

  }).call(this);
  SignedBlock = (function() {
    class SignedBlock extends Block {
      // Positive and negative integer entries only!
      constructor(position, entries) {
        super(position, entries);
      }

      reduce_jigsaw(size) {
        var edge_to_polyomino, num;
        edge_to_polyomino = function(num) { // Encodes a number edge into a jigsaw edge
          var entries, i, poly, pos_num;
          pos_num = Math.abs(num);
          entries = [];
          i = 2;
          while (pos_num > 0) {
            if (modulo(pos_num, 2) !== 0) {
              entries.push([i, 0]);
            }
            pos_num = Math.floor(pos_num / 2);
            i += 1;
          }
          poly = new Polyomino([0, 0], entries);
          if (num > 0) {
            poly.rotate_around(Piece.CCW_180, size / 2, 0);
          }
          console.log('After', poly.entries.toArray());
          return poly;
        };
        return new Jigsaw([0, 0], (function() {
          var j, len, ref, results;
          ref = this.entries;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            num = ref[j];
            results.push(edge_to_polyomino(num));
          }
          return results;
        }).call(this));
      }

    };

    
    // SVG
    SignedBlock.Tile = SVG.invent({
      create: 'g',
      inherit: SVG.G,
      extend: {
        constructor_: function(entries) {
          var abs, colors, d, digits, height, i, j, k, l, polygon, ref;
          this.block_tile(entries);
          colors = ['#000', '#222', '#444', '#666', '#999', '#bbb', '#ddd', '#fff'];
          for (i = j = 0; j < 4; i = ++j) {
            this.polygon([[0.5, -0.5], [0.25, -0.25], [0.25, 0], [0.5, 0]]).fill(colors[modulo(Math.abs(entries[i]), colors.length / 2) + (entries[i] < 0) * (colors.length / 2)]).rotate(-90 * i, 0, 0);
            this.polygon([[0.5, 0.5], [0.25, 0.25], [0.25, 0], [0.5, 0]]).fill(colors[modulo(Math.abs(entries[i]), colors.length / 2) + (entries[i] > 0) * (colors.length / 2)]).rotate(-90 * i, 0, 0);
          }
          for (i = k = 0; k < 4; i = ++k) {
            abs = Math.abs(entries[i]);
            digits = Math.floor(Math.max(0, Math.log2(abs)) / 4) + 2; // include initial 0 to prevent digit-splitting cheats like fe -> ffee
            for (d = l = 0, ref = digits; (0 <= ref ? l < ref : l > ref); d = 0 <= ref ? ++l : --l) {
              height = 0.25 - 0.5 * (2 * digits - 1 - 2 * d) / (2 * digits - 1);
              polygon = entries[i] >= 0 ? this.polygon([[0.5, height], [0.25, height], [0.25, 0.25], [0.5, 0.25]]) : this.polygon([[0.5, -height], [0.25, -height], [0.25, -0.25], [0.5, -0.25]]);
              polygon.fill(Block.STRIP_COLORS[modulo(abs, 0x10)]).rotate(-90 * i, 0, 0);
              abs = Math.floor(abs / 0x10);
            }
          }
          return this;
        }
      },
      construct: {
        sblock_tile: function(entries) {
          return this.put(new SignedBlock.Tile).constructor_(entries);
        }
      }
    });

    return SignedBlock;

  }).call(this);
  Jigsaw = (function() {
    class Jigsaw extends Block {
      // Entries are polyominos XOR'd with a block
      constructor(position, entries) {
        super(position, entries);
      }

      reduce_polyomino(size) {
        var entry, j, len, poly, ref, rotation, square;
        square = Polyomino.square(size);
        ref = _.zip(this.entries, [Piece.CCW_270, Piece.CCW_0, Piece.CCW_90, Piece.CCW_180]);
        for (j = 0, len = ref.length; j < len; j++) {
          [entry, rotation] = ref[j];
          poly = entry.copy();
          poly.rotate_around(rotation, size / 2, size / 2);
          square.this_xor(poly);
        }
        return square;
      }

      static tile_drag_end(e) {
        this.x(this.piece.position[0] + 0.5);
        this.y(this.piece.position[1] + 0.5);
        if (this.should_rotate) {
          //@inner.rotate Math.round (@inner.transform().rotation - 90) % 360, 0, 0
          this.piece.rotate(Piece.CCW_90);
          this.inner.remove();
          return this.inner = this.jigsaw_tile(this.piece, this.puzzle.size);
        }
      }

    };

    
    // SVG
    Jigsaw.Tile = SVG.invent({
      create: 'g',
      inherit: SVG.G,
      extend: {
        constructor_: function(jigsaw, size) {
          var poly;
          poly = jigsaw.reduce_polyomino(size);
          this.polyomino_tile(poly, 1 / 4).scale(1 / size, 0, 0).move(-0.5 * size, -0.5 * size);
          return this;
        }
      },
      construct: {
        jigsaw_tile: function(jigsaw, size) {
          return this.put(new Jigsaw.Tile).constructor_(jigsaw, size);
        }
      }
    });

    return Jigsaw;

  }).call(this);
  Polyomino = (function() {
    class Polyomino extends Piece {
      // Stores entries as a list of offset positions
      constructor(position, entries1) {
        super(position);
        this.entries = entries1;
        if (!(this.entries instanceof Set)) {
          this.entries = new Set(this.entries);
        }
      }

      copy(other) {
        var poly;
        return poly = new Polyomino(this.position.slice(0), new Set(this.entries));
      }

      static square(size) {
        var entries, x, y;
        entries = _.flatten((function() {
          var j, ref, results;
          results = [];
          for (y = j = 0, ref = size; (0 <= ref ? j < ref : j > ref); y = 0 <= ref ? ++j : --j) {
            results.push((function() {
              var k, ref1, results1;
              results1 = [];
              for (x = k = 0, ref1 = size; (0 <= ref1 ? k < ref1 : k > ref1); x = 0 <= ref1 ? ++k : --k) {
                results1.push([x, y]);
              }
              return results1;
            })());
          }
          return results;
        })(), true);
        return new Polyomino([0, 0], entries);
      }

      this_xor(other) { // XORs and modifies this polyomino with `other`, used for reducing jigsaw pieces to polyominos
        // Doesn't care about position
        return this.entries = this.entries.xor(other.entries);
      }

      shift_offset(x, y) { // shifts the offsets of the blocks instead of the overall position
        this.entries.forEach(function(entry) {
          entry[0] += x;
          return entry[1] += y;
        });
        return this.entries.rebuild();
      }

      rotate_offset(amount) { // rotates offsets counterclockwise around the origin, amount is Piece.CCW_xx
        return this.entries = (function() {
          switch (amount) {
            case Piece.CCW_90:
              return new Set(this.entries.map(function(entry) {
                return [entry[1], -entry[0] - 1];
              }));
            case Piece.CCW_180:
              return new Set(this.entries.map(function(entry) {
                return [-entry[0] - 1, -entry[1] - 1];
              }));
            case Piece.CCW_270:
              return new Set(this.entries.map(function(entry) {
                return [-entry[1] - 1, entry[0]];
              }));
            default:
              return this.entries;
          }
        }).call(this);
      }

      rotate_around(amount, x, y) {
        this.shift_offset(-x, -y);
        this.rotate_offset(amount);
        this.shift_offset(x, y);
        return console.log('During', this.entries.toArray());
      }

      reoffset() {
        var min_x, min_y;
        // Re-offset to origin
        [min_x, min_y] = [
          this.entries.min(function(a,
          b) {
            return a[0] - b[0];
          })[0],
          this.entries.min(function(a,
          b) {
            return a[1] - b[1];
          })[1]
        ];
        this.entries.forEach(function(entry) {
          entry[0] -= min_x;
          return entry[1] -= min_y;
        });
        return this.entries.rebuild();
      }

      rotate(amount) {
        this.rotate_offset(amount);
        return this.reoffset();
      }

      neighbors(point) { // returns the neighbors of a point in right, up, left, down order
        return [this.entries.contains([point[0] + 1, point[1]]) ? [point[0] + 1, point[1]] : null, this.entries.contains([point[0], point[1] - 1]) ? [point[0], point[1] - 1] : null, this.entries.contains([point[0] - 1, point[1]]) ? [point[0] - 1, point[1]] : null, this.entries.contains([point[0], point[1] + 1]) ? [point[0], point[1] + 1] : null];
      }

      boundary() { // returns the boundary as a list of loops, where each loop is a list of points
        var curr, edge_graph, edge_points, loop_, loops, next;
        edge_points = function(entry, side) {
          switch (side) {
            case Block.RIGHT:
              return [[entry[0] + 1, entry[1] + 1], [entry[0] + 1, entry[1] + 0]];
            case Block.TOP:
              return [[entry[0] + 1, entry[1] + 0], [entry[0] + 0, entry[1] + 0]];
            case Block.LEFT:
              return [[entry[0] + 0, entry[1] + 0], [entry[0] + 0, entry[1] + 1]];
            case Block.BOTTOM:
              return [[entry[0] + 0, entry[1] + 1], [entry[0] + 1, entry[1] + 1]];
          }
        };
        
        // Edge graph
        edge_graph = new Hash();
        this.entries.forEach((entry) => {
          var edge, i, j, len, nb, ref, results;
          ref = this.neighbors(entry);
          results = [];
          for (i = j = 0, len = ref.length; j < len; i = ++j) {
            nb = ref[i];
            if (nb == null) {
              edge = edge_points(entry, i);
              
              // Add the edge to the graph
              if (!edge_graph.hasKey(edge[0])) {
                edge_graph.put(edge[0], new Set());
              }
              if (!edge_graph.hasKey(edge[1])) {
                edge_graph.put(edge[1], new Set());
              }
              edge_graph.get(edge[0]).add(edge[1]);
              results.push(edge_graph.get(edge[1]).add(edge[0]));
            } else {
              results.push(void 0);
            }
          }
          return results;
        });
        
        // Traverse the edge graph for loops
        loops = [];
        while (!edge_graph.isEmpty()) {
          curr = edge_graph.first().key; // use the Axiom of Choice to pick a vertex from this graph :)
          loop_ = [curr];
          while (edge_graph.hasKey(curr)) {
            next = edge_graph.get(curr).first();
            loop_.push(next);
            edge_graph.get(curr).remove(next);
            if (edge_graph.get(curr).isEmpty()) {
              edge_graph.remove(curr);
            }
            edge_graph.get(next).remove(curr);
            if (edge_graph.get(next).isEmpty()) {
              edge_graph.remove(next);
            }
            curr = next;
          }
          loops.push(loop_);
        }
        return loops;
      }

      reduce_unsigned(common, ustart) { // common: common number to use for edge, ustart: start of unique numbers
        var block_map;
        block_map = new Hash(_.flatten(this.entries.map(function(entry) {
          var i;
          return [
            entry,
            (function() {
              var j,
            results;
              results = [];
              for (i = j = 0; j < 4; i = ++j) {
                results.push(void 0);
              }
              return results;
            })()
          ];
        }), true));
        this.entries.forEach((entry) => {
          var i, j, len, nb, ref, results;
          ref = this.neighbors(entry);
          results = [];
          for (i = j = 0, len = ref.length; j < len; i = ++j) {
            nb = ref[i];
            if ((nb != null) && this.entries.contains(nb)) {
              if (block_map.get(entry)[i] == null) {
                block_map.get(entry)[i] = ustart; // edges inside jigsaw get unique color that acts like glue
                block_map.get(nb)[(i + 2) % 4] = ustart;
                results.push(ustart += 1);
              } else {
                results.push(void 0);
              }
            } else {
              results.push(block_map.get(entry)[i] = common); // edges of jigsaw get color common to all edges
            }
          }
          return results;
        });
        return [
          block_map.map(function(pair) {
            return new UnsignedBlock(pair.key.slice(0),
          pair.value);
          }),
          ustart
        ];
      }

      static tile_before_drag(e) {
        return this.should_rotate = true;
      }

      static tile_drag_move(e) {
        var x, y;
        this.front();
        [x, y] = [Math.floor(this.x() + 0.5), Math.floor(this.y() + 0.5)];
        if (x !== this.piece.position[0] || y !== this.piece.position[1]) {
          this.should_rotate = false;
          return this.piece.position = [x, y];
        }
      }

      static tile_drag_end(e) {
        this.x(this.piece.position[0]);
        this.y(this.piece.position[1]);
        if (this.should_rotate) {
          this.piece.rotate(Piece.CCW_90);
          this.inner.remove();
          return this.inner = this.polyomino_tile(this.piece);
        }
      }

    };

    
    // SVG
    Polyomino.Tile = SVG.invent({
      create: 'g',
      inherit: SVG.G,
      extend: {
        constructor_: function(poly, thickness) {
          var bflat, boundary, j, len, loop_;
          boundary = poly.boundary();
          bflat = _.flatten(boundary, true);
          this.polygon(bflat).fill({
            color: '#00ffff80',
            rule: 'evenodd'
          });
          for (j = 0, len = boundary.length; j < len; j++) {
            loop_ = boundary[j];
            this.polyline(loop_).fill('none').stroke({
              color: '#00f',
              width: thickness != null ? thickness : 1 / 16
            });
          }
          return this;
        }
      },
      construct: {
        polyomino_tile: function(poly, thickness) {
          return this.put(new Polyomino.Tile).constructor_(poly, thickness);
        }
      }
    });

    return Polyomino;

  }).call(this);
  Puzzle = class Puzzle {
    constructor(width1, height1) {
      this.width = width1;
      this.height = height1;
    }

    from_3_partition(nums) {}

    init_render(draw) {} // Renders the puzzle

    reduce() {}

  };
  EdgeMatch = class EdgeMatch extends Puzzle {
    constructor(width, height, pieces1) {
      super(width, height);
      this.pieces = pieces1;
    }

    get_piece(x, y) {
      return this.pieces[y * this.width + x];
    }

    set_piece(x, y, piece) {
      return this.pieces[y * this.width + x] = piece;
    }

    swap_pieces(x1, y1, x2, y2) { //Assumes that the piece at x1, y1 is invading the spot x2, y2
      var piece1, piece2, ref;
      piece1 = this.get_piece(x1, y1);
      piece2 = this.get_piece(x2, y2);
      piece1.position = [x2, y2];
      if (piece2 != null) {
        piece2.position = [x1, y1];
      }
      if (piece2 != null) {
        if ((ref = piece2.svg) != null) {
          ref.animate(400, '>').x(x1 + 0.5).y(y1 + 0.5);
        }
      }
      this.set_piece(x1, y1, piece2);
      return this.set_piece(x2, y2, piece1);
    }

    init_render(draw, element_func) {
      var j, k, l, piece, ref, ref1, ref2, results, tile, x, y;
// note: 2 dots
      for (x = j = 0, ref = this.width; (0 <= ref ? j <= ref : j >= ref); x = 0 <= ref ? ++j : --j) {
        draw.line(x, 0, x, this.height).stroke({
          color: '#ddd',
          width: 1 / 16
        });
      }
      for (y = k = 0, ref1 = this.height; (0 <= ref1 ? k <= ref1 : k >= ref1); y = 0 <= ref1 ? ++k : --k) {
        draw.line(0, y, this.width, y).stroke({
          color: '#ddd',
          width: 1 / 16
        });
      }
      results = [];
      for (y = l = 0, ref2 = this.height; (0 <= ref2 ? l < ref2 : l > ref2); y = 0 <= ref2 ? ++l : --l) {
        results.push((function() {
          var m, ref3, results1;
          results1 = [];
          for (x = m = 0, ref3 = this.width; (0 <= ref3 ? m < ref3 : m > ref3); x = 0 <= ref3 ? ++m : --m) {
            piece = this.get_piece(x, y);
            if (piece != null) {
              tile = draw.group(); // Make a group buffer because otherwise svg.draggable assumes that rotations need to be respected
              tile.inner = element_func.call(tile, this.get_piece(x, y).entries);
              tile.move(x + 0.5, y + 0.5);
              if (x > 0 && x < this.width - 1 && y > 0 && y < height - 1) {
                tile.draggable({
                  minX: 1.5,
                  maxX: this.width - 0.5,
                  minY: 1.5,
                  maxY: this.height - 0.5
                }).on('beforedrag', Block.tile_before_drag).on('dragmove', Block.tile_drag_move).on('dragend', Block.tile_drag_end);
              }
              tile.puzzle = this;
              tile.piece = piece;
              results1.push(piece.svg = tile);
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    }

  };
  UnsignedEdgeMatch = (function() {
    class UnsignedEdgeMatch extends EdgeMatch {
      constructor(width, height, pieces) {
        var i;
        if (!pieces) {
          pieces = (function() {
            var j, ref, results;
            results = [];
            for (i = j = 0, ref = width * height; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
              results.push(new UnsignedBlock([modulo(i, width), Math.floor(i / width)], (function() {
                var k, results1;
                results1 = [];
                for (i = k = 0; k < 4; i = ++k) {
                  results1.push(void 0);
                }
                return results1;
              })()));
            }
            return results;
          })();
        }
        super(width, height, pieces);
      }

      static reduce_to() {
        return SignedEdgeMatch;
      }

      reduce() {
        var j, k, l, len, m, n, piece, ref, ref1, ref2, ref3, ref4, sblock, sem, unique, x, y;
        sem = new SignedEdgeMatch(2 * this.width - 2, 2 * this.height - 2);
        
        // Corners
        sem.get_piece(0, 0).entries = this.get_piece(0, 0).entries.slice(0);
        sem.get_piece(sem.width - 1, 0).entries = this.get_piece(this.width - 1, 0).entries.slice(0);
        sem.get_piece(0, sem.height - 1).entries = this.get_piece(0, this.height - 1).entries.slice(0);
        sem.get_piece(sem.width - 1, sem.height - 1).entries = this.get_piece(this.width - 1, this.height - 1).entries.slice(0);

// Edges
        for (x = j = 1, ref = this.width - 1; (1 <= ref ? j < ref : j > ref); x = 1 <= ref ? ++j : --j) {
          sem.get_piece(2 * x, 0).entries = this.get_piece(x, 0).entries.slice(0);
          (sem.get_piece(2 * x - 1, 0).entries = this.get_piece(x, 0).entries.slice(0))[Block.BOTTOM] *= -1;
          sem.get_piece(2 * x - 1, sem.height - 1).entries = this.get_piece(x, this.height - 1).entries.slice(0);
          (sem.get_piece(2 * x, sem.height - 1).entries = this.get_piece(x, this.height - 1).entries.slice(0))[Block.TOP] *= -1;
        }
        for (y = k = 1, ref1 = this.height - 1; (1 <= ref1 ? k < ref1 : k > ref1); y = 1 <= ref1 ? ++k : --k) {
          sem.get_piece(0, 2 * y - 1).entries = this.get_piece(0, y).entries.slice(0);
          (sem.get_piece(0, 2 * y).entries = this.get_piece(0, y).entries.slice(0))[Block.RIGHT] *= -1;
          sem.get_piece(sem.width - 1, 2 * y).entries = this.get_piece(this.width - 1, y).entries.slice(0);
          (sem.get_piece(sem.width - 1, 2 * y - 1).entries = this.get_piece(this.width - 1, y).entries.slice(0))[Block.LEFT] *= -1;
        }
        unique = 1 + Math.max(...((function() {
          var l, len, ref2, results;
          ref2 = this.pieces;
          results = [];
          for (l = 0, len = ref2.length; l < len; l++) {
            piece = ref2[l];
            if (piece != null) {
              results.push(Math.max(...piece.entries));
            }
          }
          return results;
        }).call(this)));
        for (y = l = 1, ref2 = this.height - 1; (1 <= ref2 ? l < ref2 : l > ref2); y = 1 <= ref2 ? ++l : --l) {
          for (x = m = 1, ref3 = this.width - 1; (1 <= ref3 ? m < ref3 : m > ref3); x = 1 <= ref3 ? ++m : --m) {
            if (this.get_piece(x, y) != null) {
              ref4 = this.get_piece(x, y).reduce_signed(unique, unique + 1, unique + 2, unique + 3);
              for (n = 0, len = ref4.length; n < len; n++) {
                sblock = ref4[n];
                sem.get_piece(2 * x - 1 + sblock.position[0], 2 * y - 1 + sblock.position[1]).entries = sblock.entries;
              }
              unique += 4;
            }
          }
        }
        return [sem, 2];
      }

      static from_3_partition(nums) {
        var common_horz, common_vert, height, i, index, j, k, l, len, m, n, num, o, p, piece, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, s, target_sum, uem, unique, width, x, y;
        target_sum = target_sum_3_partition(nums);
        width = target_sum + 2;
        height = nums.length / 3 + 2;
        uem = new UnsignedEdgeMatch(width, height);

// Update positions
        for (y = j = 0, ref = height; (0 <= ref ? j < ref : j > ref); y = 0 <= ref ? ++j : --j) {
          for (x = k = 0, ref1 = width; (0 <= ref1 ? k < ref1 : k > ref1); x = 0 <= ref1 ? ++k : --k) {
            uem.get_piece(x, y).position = [x, y];
          }
        }

// Frame outside
        for (x = l = 0, ref2 = width; (0 <= ref2 ? l < ref2 : l > ref2); x = 0 <= ref2 ? ++l : --l) {
          uem.get_piece(x, 0).entries[Block.TOP] = 0;
          uem.get_piece(x, height - 1).entries[Block.BOTTOM] = 0;
        }
        for (y = m = 0, ref3 = height; (0 <= ref3 ? m < ref3 : m > ref3); y = 0 <= ref3 ? ++m : --m) {
          uem.get_piece(0, y).entries[Block.LEFT] = 0;
          uem.get_piece(width - 1, y).entries[Block.RIGHT] = 0;
        }

// Frame inside
        for (x = n = 0, ref4 = width - 1; (0 <= ref4 ? n < ref4 : n > ref4); x = 0 <= ref4 ? ++n : --n) {
          uem.get_piece(x, 0).entries[Block.RIGHT] = 0;
          uem.get_piece(x + 1, 0).entries[Block.LEFT] = 0;
          uem.get_piece(x, height - 1).entries[Block.RIGHT] = 0;
          uem.get_piece(x + 1, height - 1).entries[Block.LEFT] = 0;
        }
        for (y = o = 0, ref5 = height - 1; (0 <= ref5 ? o < ref5 : o > ref5); y = 0 <= ref5 ? ++o : --o) {
          uem.get_piece(0, y).entries[Block.BOTTOM] = 0;
          uem.get_piece(0, y + 1).entries[Block.TOP] = 0;
          uem.get_piece(width - 1, y).entries[Block.BOTTOM] = 0;
          uem.get_piece(width - 1, y + 1).entries[Block.TOP] = 0;
        }
        common_horz = 1;
        common_vert = 2;
        unique = 3;
// Give the inner frame the "glue" color
        for (x = p = 1, ref6 = width - 1; (1 <= ref6 ? p < ref6 : p > ref6); x = 1 <= ref6 ? ++p : --p) {
          uem.get_piece(x, 0).entries[Block.BOTTOM] = common_vert;
          uem.get_piece(x, height - 1).entries[Block.TOP] = common_vert;
        }
        for (y = q = 1, ref7 = height - 1; (1 <= ref7 ? q < ref7 : q > ref7); y = 1 <= ref7 ? ++q : --q) {
          uem.get_piece(0, y).entries[Block.RIGHT] = common_horz;
          uem.get_piece(width - 1, y).entries[Block.LEFT] = common_horz;
        }
        
        // Now for the filling in the pie: all the a_i gadgets
        index = 0;
        for (r = 0, len = nums.length; r < len; r++) {
          num = nums[r];
          for (i = s = 0, ref8 = num; (0 <= ref8 ? s < ref8 : s > ref8); i = 0 <= ref8 ? ++s : --s) {
            piece = uem.get_piece(modulo(index, width - 2) + 1, Math.floor(index / (width - 2)) + 1);
            piece.entries[Block.TOP] = common_vert;
            piece.entries[Block.BOTTOM] = common_vert;
            piece.entries[Block.LEFT] = i === 0 ? common_horz : unique;
            if (i !== 0) {
              unique += 1;
            }
            piece.entries[Block.RIGHT] = i === num - 1 ? common_horz : unique;
            index += 1;
          }
        }
        return uem;
      }

      init_render(draw) {
        return super.init_render(draw, draw.ublock_tile);
      }

    };

    UnsignedEdgeMatch.puzzle_name = 'Unsigned Edge Matching with Frame';

    return UnsignedEdgeMatch;

  }).call(this);
  SignedEdgeMatch = (function() {
    class SignedEdgeMatch extends EdgeMatch {
      constructor(width, height, pieces) {
        var i;
        if (!pieces) {
          pieces = (function() {
            var j, ref, results;
            results = [];
            for (i = j = 0, ref = width * height; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
              results.push(new SignedBlock([modulo(i, width), Math.floor(i / width)], (function() {
                var k, results1;
                results1 = [];
                for (i = k = 0; k < 4; i = ++k) {
                  results1.push(void 0);
                }
                return results1;
              })()));
            }
            return results;
          })();
        }
        super(width, height, pieces);
      }

      static reduce_to() {
        return JigsawPuzzle;
      }

      static from_3_partition(nums) {
        var common_horz, common_vert, height, i, index, j, k, l, len, m, n, num, o, p, piece, q, ref, ref1, ref2, ref3, ref4, ref5, ref6, sem, target_sum, unique, width, x, y;
        target_sum = target_sum_3_partition(nums);
        width = target_sum + 2;
        height = nums.length / 3 + 2;
        sem = new SignedEdgeMatch(width, height);

// Give the frame the same color, since a piece of the opposite color would be needed for a match
        for (x = j = 0, ref = width; (0 <= ref ? j < ref : j > ref); x = 0 <= ref ? ++j : --j) {
          sem.get_piece(x, 0).entries[Block.TOP] = 0;
          sem.get_piece(x, height - 1).entries[Block.BOTTOM] = 0;
        }
        for (y = k = 0, ref1 = height; (0 <= ref1 ? k < ref1 : k > ref1); y = 0 <= ref1 ? ++k : --k) {
          sem.get_piece(0, y).entries[Block.LEFT] = 0;
          sem.get_piece(width - 1, y).entries[Block.RIGHT] = 0;
        }

// Frame inside
        for (x = l = 0, ref2 = width - 1; (0 <= ref2 ? l < ref2 : l > ref2); x = 0 <= ref2 ? ++l : --l) {
          sem.get_piece(x, 0).entries[Block.RIGHT] = 0;
          sem.get_piece(x + 1, 0).entries[Block.LEFT] = 0;
          sem.get_piece(x, height - 1).entries[Block.RIGHT] = 0;
          sem.get_piece(x + 1, height - 1).entries[Block.LEFT] = 0;
        }
        for (y = m = 0, ref3 = height - 1; (0 <= ref3 ? m < ref3 : m > ref3); y = 0 <= ref3 ? ++m : --m) {
          sem.get_piece(0, y).entries[Block.BOTTOM] = 0;
          sem.get_piece(0, y + 1).entries[Block.TOP] = 0;
          sem.get_piece(width - 1, y).entries[Block.BOTTOM] = 0;
          sem.get_piece(width - 1, y + 1).entries[Block.TOP] = 0;
        }
        common_horz = 1;
        common_vert = 2;
        unique = 3;
// Give the inner frame the "glue" color
        for (x = n = 1, ref4 = width - 1; (1 <= ref4 ? n < ref4 : n > ref4); x = 1 <= ref4 ? ++n : --n) {
          sem.get_piece(x, 0).entries[Block.BOTTOM] = common_vert;
          sem.get_piece(x, height - 1).entries[Block.TOP] = -common_vert;
        }
        for (y = o = 1, ref5 = height - 1; (1 <= ref5 ? o < ref5 : o > ref5); y = 1 <= ref5 ? ++o : --o) {
          sem.get_piece(0, y).entries[Block.RIGHT] = common_horz;
          sem.get_piece(width - 1, y).entries[Block.LEFT] = -common_horz;
        }
        
        // Now for the filling in the pie: all the a_i gadgets
        index = 0;
        for (p = 0, len = nums.length; p < len; p++) {
          num = nums[p];
          for (i = q = 0, ref6 = num; (0 <= ref6 ? q < ref6 : q > ref6); i = 0 <= ref6 ? ++q : --q) {
            piece = sem.get_piece(modulo(index, width - 2) + 1, Math.floor(index / (width - 2)) + 1);
            piece.entries[Block.TOP] = -common_vert;
            piece.entries[Block.BOTTOM] = common_vert;
            piece.entries[Block.LEFT] = i === 0 ? -common_horz : -unique;
            if (i !== 0) {
              unique += 1;
            }
            piece.entries[Block.RIGHT] = i === num - 1 ? common_horz : unique;
            index += 1;
          }
        }
        return sem;
      }

      init_render(draw) {
        return super.init_render(draw, draw.sblock_tile);
      }

    };

    SignedEdgeMatch.puzzle_name = 'Signed Edge Matching with Frame';

    return SignedEdgeMatch;

  }).call(this);
  JigsawPuzzle = (function() {
    class JigsawPuzzle extends EdgeMatch {
      constructor(width, height, size1, pieces) {
        var i;
        if (!pieces) {
          pieces = (function() {
            var j, ref, results;
            results = [];
            for (i = j = 0, ref = width * height; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
              results.push(new Jigsaw([modulo(i, width), Math.floor(i / width)], (function() {
                var k, results1;
                results1 = [];
                for (i = k = 0; k < 4; i = ++k) {
                  results1.push(void 0);
                }
                return results1;
              })()));
            }
            return results;
          })();
        }
        super(width, height, pieces);
        this.size = size1;
      }

      static reduce_to() {
        return PolyominoPack;
      }

      static from_3_partition(nums) {
        var j, jp, k, l, m, piece, ref, ref1, ref2, ref3, sem, unique, x, y;
        sem = SignedEdgeMatch.from_3_partition(nums);
        unique = 1 + Math.max(...((function() {
          var j, len, ref, results;
          ref = sem.pieces;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            piece = ref[j];
            if (piece != null) {
              results.push(Math.max(...piece.entries));
            }
          }
          return results;
        })()));

// Fix frame inside
        for (x = j = 0, ref = sem.width - 1; (0 <= ref ? j < ref : j > ref); x = 0 <= ref ? ++j : --j) {
          sem.get_piece(x, 0).entries[Block.RIGHT] = unique;
          sem.get_piece(x + 1, 0).entries[Block.LEFT] = -unique;
          sem.get_piece(x, sem.height - 1).entries[Block.RIGHT] = -unique - 1;
          sem.get_piece(x + 1, sem.height - 1).entries[Block.LEFT] = unique + 1;
          unique += 2;
        }
        for (y = k = 0, ref1 = sem.height - 1; (0 <= ref1 ? k < ref1 : k > ref1); y = 0 <= ref1 ? ++k : --k) {
          sem.get_piece(0, y).entries[Block.BOTTOM] = -unique;
          sem.get_piece(0, y + 1).entries[Block.TOP] = unique;
          sem.get_piece(sem.width - 1, y).entries[Block.BOTTOM] = unique + 1;
          sem.get_piece(sem.width - 1, y + 1).entries[Block.TOP] = -unique - 1;
        }
        jp = new JigsawPuzzle(sem.width, sem.height, 5 + Math.floor(Math.log2(unique - 1)));
        for (y = l = 0, ref2 = jp.height; (0 <= ref2 ? l < ref2 : l > ref2); y = 0 <= ref2 ? ++l : --l) {
          for (x = m = 0, ref3 = jp.width; (0 <= ref3 ? m < ref3 : m > ref3); x = 0 <= ref3 ? ++m : --m) {
            jp.get_piece(x, y).entries = sem.get_piece(x, y).reduce_jigsaw(jp.size).entries;
          }
        }
        return jp;
      }

      init_render(draw) { // size used only for jigsaw
        var j, k, l, piece, ref, ref1, ref2, results, tile, x, y;
// note: 2 dots
        for (x = j = 0, ref = this.width; (0 <= ref ? j <= ref : j >= ref); x = 0 <= ref ? ++j : --j) {
          draw.line(x, 0, x, this.height).stroke({
            color: '#ddd',
            width: 1 / 16
          });
        }
        for (y = k = 0, ref1 = this.height; (0 <= ref1 ? k <= ref1 : k >= ref1); y = 0 <= ref1 ? ++k : --k) {
          draw.line(0, y, this.width, y).stroke({
            color: '#ddd',
            width: 1 / 16
          });
        }
        results = [];
        for (y = l = 0, ref2 = this.height; (0 <= ref2 ? l < ref2 : l > ref2); y = 0 <= ref2 ? ++l : --l) {
          results.push((function() {
            var m, ref3, results1;
            results1 = [];
            for (x = m = 0, ref3 = this.width; (0 <= ref3 ? m < ref3 : m > ref3); x = 0 <= ref3 ? ++m : --m) {
              piece = this.get_piece(x, y);
              if (piece != null) {
                tile = draw.group(); // Make a group buffer because otherwise svg.draggable assumes that rotations need to be respected
                tile.inner = tile.jigsaw_tile(this.get_piece(x, y), this.size);
                tile.move(x + 0.5, y + 0.5);
                tile.draggable({
                  minX: 0.5,
                  maxX: this.width + 0.5,
                  minY: 0.5,
                  maxY: this.height + 0.5
                }).on('beforedrag', Block.tile_before_drag).on('dragmove', Block.tile_drag_move).on('dragend', Jigsaw.tile_drag_end);
                tile.puzzle = this;
                tile.piece = piece;
                results1.push(piece.svg = tile);
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          }).call(this));
        }
        return results;
      }

    };

    JigsawPuzzle.puzzle_name = 'Jigsaw Puzzle';

    return JigsawPuzzle;

  }).call(this);
  PolyominoPack = (function() {
    class PolyominoPack extends Puzzle {
      constructor(width, height, pieces1) { // Expects an array of pieces
        super(width, height);
        this.pieces = pieces1;
        if (!this.pieces) {
          this.pieces = [];
        }
      }

      static reduce_to() {
        return UnsignedEdgeMatch;
      }

      reduce() {
        var common, free_points, j, k, l, len, len1, m, n, o, p, piece, position, q, ref, ref1, ref2, ref3, ref4, ref5, ref6, ublock, ublocks, uem, unique, x, y;
        uem = new UnsignedEdgeMatch(this.width + 2, this.height + 2);
// Frame outside
        for (x = j = 0, ref = uem.width; (0 <= ref ? j < ref : j > ref); x = 0 <= ref ? ++j : --j) {
          uem.get_piece(x, 0).entries[Block.TOP] = 0;
          uem.get_piece(x, uem.height - 1).entries[Block.BOTTOM] = 0;
        }
        for (y = k = 0, ref1 = uem.height; (0 <= ref1 ? k < ref1 : k > ref1); y = 0 <= ref1 ? ++k : --k) {
          uem.get_piece(0, y).entries[Block.LEFT] = 0;
          uem.get_piece(uem.width - 1, y).entries[Block.RIGHT] = 0;
        }

// Frame inside
        for (x = l = 0, ref2 = uem.width - 1; (0 <= ref2 ? l < ref2 : l > ref2); x = 0 <= ref2 ? ++l : --l) {
          uem.get_piece(x, 0).entries[Block.RIGHT] = 0;
          uem.get_piece(x + 1, 0).entries[Block.LEFT] = 0;
          uem.get_piece(x, uem.height - 1).entries[Block.RIGHT] = 0;
          uem.get_piece(x + 1, uem.height - 1).entries[Block.LEFT] = 0;
        }
        for (y = m = 0, ref3 = uem.height - 1; (0 <= ref3 ? m < ref3 : m > ref3); y = 0 <= ref3 ? ++m : --m) {
          uem.get_piece(0, y).entries[Block.BOTTOM] = 0;
          uem.get_piece(0, y + 1).entries[Block.TOP] = 0;
          uem.get_piece(uem.width - 1, y).entries[Block.BOTTOM] = 0;
          uem.get_piece(uem.width - 1, y + 1).entries[Block.TOP] = 0;
        }
        common = 1;
        unique = 2;
// Give the inner frame the "glue" color
        for (x = n = 1, ref4 = uem.width - 1; (1 <= ref4 ? n < ref4 : n > ref4); x = 1 <= ref4 ? ++n : --n) {
          uem.get_piece(x, 0).entries[Block.BOTTOM] = common;
          uem.get_piece(x, uem.height - 1).entries[Block.TOP] = common;
        }
        for (y = o = 1, ref5 = uem.height - 1; (1 <= ref5 ? o < ref5 : o > ref5); y = 1 <= ref5 ? ++o : --o) {
          uem.get_piece(0, y).entries[Block.RIGHT] = common;
          uem.get_piece(uem.width - 1, y).entries[Block.LEFT] = common;
        }
        free_points = new Set(_.flatten((function() {
          var p, ref6, results;
          results = [];
          for (y = p = 1, ref6 = uem.height - 1; (1 <= ref6 ? p < ref6 : p > ref6); y = 1 <= ref6 ? ++p : --p) {
            results.push((function() {
              var q, ref7, results1;
              results1 = [];
              for (x = q = 1, ref7 = uem.width - 1; (1 <= ref7 ? q < ref7 : q > ref7); x = 1 <= ref7 ? ++q : --q) {
                results1.push([x, y]);
              }
              return results1;
            })());
          }
          return results;
        })(), true));
        ref6 = this.pieces;
        
        //debug
        //for y in [1...uem.height - 1]
        //	for x in [1...uem.width - 1]
        //		uem.get_piece(x, y).entries = [0,0,0,0]
        for (p = 0, len = ref6.length; p < len; p++) {
          piece = ref6[p];
          [ublocks, unique] = piece.reduce_unsigned(common, unique);
          for (q = 0, len1 = ublocks.length; q < len1; q++) {
            ublock = ublocks[q];
            position = [piece.position[0] + ublock.position[0] + 1, piece.position[1] + ublock.position[1] + 1];
            if (!free_points.contains(position)) {
              position = free_points.first();
            }
            uem.get_piece(position[0], position[1]).entries = ublock.entries;
            free_points.remove(position);
          }
        }
        return [uem, 1];
      }

      static from_3_partition(nums) {
        var frame, height, i, j, k, l, len, num, num_sum, pp, ref, ref1, target_sum, width, x, y;
        target_sum = target_sum_3_partition(nums);
        width = target_sum + 2;
        height = nums.length / 3 * 2 - 1;
        pp = new PolyominoPack(width, height);
        frame = new Polyomino([0, 0], []);
        for (y = j = 0, ref = height; (0 <= ref ? j < ref : j > ref); y = 0 <= ref ? ++j : --j) {
          frame.entries.add([0, y]);
          if (y % 2 !== 0) {
            for (x = k = 1, ref1 = width - 1; (1 <= ref1 ? k < ref1 : k > ref1); x = 1 <= ref1 ? ++k : --k) {
              frame.entries.add([x, y]);
            }
          }
          frame.entries.add([width - 1, y]);
        }
        pp.pieces.push(frame);
        num_sum = 0;
        y = 0;
        for (l = 0, len = nums.length; l < len; l++) {
          num = nums[l];
          pp.pieces.push(new Polyomino([num_sum + 1, y], (function() {
            var m, ref2, results;
            results = [];
            for (i = m = 0, ref2 = num; (0 <= ref2 ? m < ref2 : m > ref2); i = 0 <= ref2 ? ++m : --m) {
              results.push([i, 0]);
            }
            return results;
          })()));
          num_sum += num;
          if (num_sum >= target_sum) {
            num_sum = 0;
            y += 2;
          }
        }
        return pp;
      }

      init_render(draw) {
        var j, k, l, len, piece, ref, ref1, ref2, results, tile, x, y;
// note: 2 dots
        for (x = j = 0, ref = this.width; (0 <= ref ? j <= ref : j >= ref); x = 0 <= ref ? ++j : --j) {
          draw.line(x, 0, x, this.height).stroke({
            color: '#ddd',
            width: 1 / 16
          });
        }
        for (y = k = 0, ref1 = this.height; (0 <= ref1 ? k <= ref1 : k >= ref1); y = 0 <= ref1 ? ++k : --k) {
          draw.line(0, y, this.width, y).stroke({
            color: '#ddd',
            width: 1 / 16
          });
        }
        ref2 = this.pieces;
        results = [];
        for (l = 0, len = ref2.length; l < len; l++) {
          piece = ref2[l];
          tile = draw.group(); // Make a group buffer because otherwise svg.draggable assumes that rotations need to be respected
          tile.inner = tile.polyomino_tile(piece);
          tile.move(piece.position[0], piece.position[1]);
          //minX: 0
          //maxX: @width
          //minY: 0
          //maxY: @height
          //)
          tile.draggable().on('beforedrag', Polyomino.tile_before_drag).on('dragmove', Polyomino.tile_drag_move).on('dragend', Polyomino.tile_drag_end);
          tile.puzzle = this;
          tile.piece = piece;
          results.push(piece.svg = tile);
        }
        return results;
      }

    };

    PolyominoPack.puzzle_name = 'Polyomino Packing';

    return PolyominoPack;

  }).call(this);
  draw = SVG(drawing);
  puzzle_type = JigsawPuzzle;
  size = 64;
  width = 0;
  height = 0;
  puzzle = null;
  set_puzzle_text = function() {
    document.getElementById('puzzle_type').innerHTML = puzzle_type.puzzle_name;
    return document.getElementById('reduce_text').value = `Reduce to ${(puzzle_type.reduce_to().puzzle_name)}`;
  };
  set_size_text = function() {
    return document.getElementById('size').value = size.toString();
  };
  set_puzzle_text();
  set_size_text();
  render_3_partition = function() {
    var bad_3_partition, j, len, num, nums, str, strs;
    str = document.getElementById('3_partition').value;
    bad_3_partition = document.getElementById('bad_3_partition');
    bad_3_partition.innerHTML = '';
    strs = _.filter(str.split(' '), function(str) {
      return str !== ''; // JavaScript for some reason keeps the empty strings
    });
    if (strs.length === 0) {
      bad_3_partition.innerHTML = "Congrats. Because you didn't enter any numbers, you just divided by 0. Catastrophe incoming...";
      return;
    }
    if (strs.length % 3 !== 0) {
      bad_3_partition.innerHTML = "The number of numbers must be divisible by 3.";
      return;
    }
    nums = [];
    for (j = 0, len = strs.length; j < len; j++) {
      str = strs[j];
      num = parseFloat(str);
      if (num < 1 || !Number.isInteger(num)) {
        bad_3_partition.innerHTML = `${str} is not a positive integer.`;
        return;
      }
      nums.push(num);
    }
    if (!Number.isInteger(target_sum_3_partition(nums))) {
      bad_3_partition.innerHTML = "The sum of the numbers must be divisible by the number of numbers divided by 3.";
      return;
    }
    puzzle = puzzle_type.from_3_partition(nums);
    return render();
  };
  render = function() {
    draw.clear();
    [width, height] = [puzzle.width, puzzle.height];
    draw.size(width * size, height * size);
    draw.viewbox(0, 0, width, height);
    return puzzle.init_render(draw);
  };
  reduce = function() {
    var blowup;
    puzzle_type = puzzle_type.reduce_to();
    set_puzzle_text();
    if (puzzle != null) {
      [puzzle, blowup] = puzzle.reduce();
      size /= blowup;
      document.getElementById('size').value = size.toString();
      return render();
    }
  };
  return set_size = function() {
    var bad_size, num;
    bad_size = document.getElementById('bad_size');
    bad_size.innerHTML = '';
    num = parseFloat(document.getElementById('size').value);
    if (!Number.isFinite(num) || num <= 0) {
      bad_size.innerHTML = 'Size must be positive.';
      return;
    }
    size = num;
    set_size_text();
    return draw.size(width * size, height * size);
  };
});


//sb = new SignedBlock [0, 0], [1, 3, -6, -7]
//jig = sb.reduce_jigsaw 7
//poly = jig.reduce_polyomino 7

//polyo = new Polyomino [0, 0], [[0, 0], [1, 0], [2, 0], [0, 1], [2, 1], [0, 2], [1, 2]]
//console.log polyo.boundary()

//str_ = ''
//for num in block.entries
//	str_ += "#{num.toString()} "
//document.getElementById('result').innerHTML = "[#{str_}]"

//test example: [1, 5, 3, 12, 8, 19, 7, 4, 13, 4, 2, 10]
