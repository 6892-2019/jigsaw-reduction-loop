// Generated by CoffeeScript 2.3.2
var render,
  modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

render = void 0;

JS.require('JS.Set', 'JS.Hash', function(Set, Hash) {
  var Block, EdgeMatch, Jigsaw, JigsawPuzzle, Piece, Polyomino, PolyominoPack, Puzzle, SignedBlock, SignedEdgeMatch, UnsignedBlock, UnsignedEdgeMatch, draw, sum, target_sum_3_partition;
  sum = function(nums) {
    return _.reduce(nums, (function(total, num) {
      return num + total;
    }), 0);
  };
  target_sum_3_partition = function(nums) {
    return sum(nums) * 3 / nums.length;
  };
  Piece = (function() {
    class Piece {
      // Basic piece of a puzzle
      constructor(position1) { // [x, y]
        this.position = position1;
      }

      rotate() {}

    };

    
    // Rotation degrees
    Piece.CCW_0 = 0;

    Piece.CCW_90 = 1;

    Piece.CCW_180 = 2;

    Piece.CCW_270 = 3;

    return Piece;

  }).call(this);
  Block = (function() {
    class Block extends Piece {
      // Stores entries in right, top, left, bottom order
      constructor(position, entries1) {
        super(position);
        this.entries = entries1;
      }

      rotate(amount) {
        var i, j, ref, results;
        results = [];
        for (i = j = 0, ref = amount; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          results.push(this.entries.unshift(this.entries.pop()));
        }
        return results;
      }

      static tile_before_drag(e) {
        return this.should_rotate = true;
      }

      static tile_drag_move(e) {
        var x, y;
        this.front();
        [x, y] = [Math.floor(this.cx()), Math.floor(this.cy())];
        if (x !== this.piece.position[0] || y !== this.piece.position[1]) {
          this.should_rotate = false;
          return this.puzzle.swap_pieces(this.piece.position[0], this.piece.position[1], x, y);
        }
      }

      static tile_drag_end(e) {
        this.x(this.piece.position[0] + 0.5);
        this.y(this.piece.position[1] + 0.5);
        if (this.should_rotate) {
          this.rotate(this.transform().rotation - 90);
          return this.piece.rotate();
        }
      }

    };

    
    // Entry indices
    Block.RIGHT = 0;

    Block.TOP = 1;

    Block.LEFT = 2;

    Block.BOTTOM = 3;

    
    // SVG
    Block.Tile = SVG.invent({
      create: 'g',
      inherit: SVG.G,
      extend: {
        constructor_: function(entries) {
          var colors, i, j;
          this.rect(1, 1).fill('ivory').move(-0.5, -0.5);
          colors = ['#000', '#555', '#aaa', '#fff'];
          for (i = j = 0; j < 4; i = ++j) {
            this.polygon([[0.5, -0.5], [0.25, -0.25], [0.25, 0.25], [0.5, 0.5]]).fill(colors[modulo(entries[i], colors.length)]).rotate(-90 * i, 0, 0);
          }
          return this;
        }
      },
      construct: {
        block_tile: function(entries) {
          return this.put(new Block.Tile).constructor_(entries);
        }
      }
    });

    
    //@STRIP_COLORS = ['#f00', '#f80', '#840', '#fc0', '#ff0', '#8f0', '#0f0', '#0f8', '#0ff', '#088', '#08f', '#00f', '#80f', '#808', '#f0f', '#f08']
    Block.STRIP_COLORS = ['#f00', '#ff0', '#0f0', '#0ff', '#00f', '#f0f', '#f88', '#880', '#080', '#088', '#88f', '#808', '#000', '#555', '#aaa', '#fff'];

    return Block;

  }).call(this);
  UnsignedBlock = (function() {
    class UnsignedBlock extends Block {
      // Positive integer entries only!
      constructor(position, entries) {
        super(position, entries);
      }

      reduce_signed(u0, u1, u2, u3) { // arguments are unique positive integers
        // Return the 4 signed blocks that can simulate this unsigned one
        return [new SignedBlock([0, 0], [-u1, this.entries[1], -this.entries[2], u2]), new SignedBlock([1, 0], [this.entries[0], -this.entries[1], u1, -u0]), new SignedBlock([0, 1], [u3, -u2, this.entries[2], -this.entries[3]]), new SignedBlock([1, 1], [-this.entries[0], u0, -u3, this.entries[3]])];
      }

    };

    
    // SVG
    UnsignedBlock.Tile = SVG.invent({
      create: 'g',
      inherit: SVG.G,
      extend: {
        constructor_: function(entries) {
          var d, digits, height, i, j, k, num, ref;
          this.block_tile(entries);
          for (i = j = 0; j < 4; i = ++j) {
            num = entries[i];
            digits = Math.floor(Math.log2(num) / 4) + 2; // include initial 0 to prevent digit-splitting cheats like fe -> ffee
            for (d = k = 0, ref = digits; (0 <= ref ? k < ref : k > ref); d = 0 <= ref ? ++k : --k) {
              height = 0.25 * (2 * digits - 1 - 2 * d) / (2 * digits - 1);
              this.polygon([[0.5, -height], [0.25, -height], [0.25, height], [0.5, height]]).fill(Block.STRIP_COLORS[modulo(num, 0x10)]).rotate(-90 * i, 0, 0);
              num = Math.floor(num / 0x10);
            }
          }
          return this;
        }
      },
      construct: {
        ublock_tile: function(entries) {
          return this.put(new UnsignedBlock.Tile).constructor_(entries);
        }
      }
    });

    return UnsignedBlock;

  }).call(this);
  SignedBlock = class SignedBlock extends Block {
    // Positive and negative integer entries only!
    constructor(position, entries) {
      super(position, entries);
    }

    reduce_jigsaw(size) {
      var edge_to_polyomino, num;
      edge_to_polyomino = function(num) { // Encodes a number edge into a jigsaw edge
        var entries, i, poly, pos_num;
        pos_num = Math.abs(num);
        entries = [];
        i = 2;
        while (pos_num > 0) {
          if (modulo(pos_num, 2) !== 0) {
            entries.push([i, 0]);
          }
          pos_num = Math.floor(pos_num / 2);
          i += 1;
        }
        poly = new Polyomino([0, 0], entries);
        if (num > 0) {
          poly.rotate_around(Piece.CCW_180, size / 2, 0);
        }
        return poly;
      };
      return new Jigsaw([0, 0], (function() {
        var j, len, ref, results;
        ref = this.entries;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          num = ref[j];
          results.push(edge_to_polyomino(num));
        }
        return results;
      }).call(this));
    }

  };
  Jigsaw = class Jigsaw extends Block {
    // Entries are polyominos XOR'd with a block
    constructor(position, entries) {
      super(position, entries);
    }

    reduce_polyomino(size) {
      var entry, j, len, poly, ref, rotation, square;
      square = Polyomino.square(size);
      ref = _.zip(this.entries, [Piece.CCW_270, Piece.CCW_0, Piece.CCW_90, Piece.CCW_180]);
      for (j = 0, len = ref.length; j < len; j++) {
        [entry, rotation] = ref[j];
        console.dir([entry, rotation]);
        poly = entry.copy();
        poly.rotate_around(rotation, size / 2, size / 2);
        square.this_xor(poly);
      }
      return square;
    }

  };
  Polyomino = class Polyomino extends Piece {
    // Stores entries as a list of offset positions
    constructor(position, entries1) {
      super(position);
      this.entries = entries1;
      if (!(this.entries instanceof Set)) {
        this.entries = new Set(this.entries);
      }
    }

    copy(other) {
      return new Polyomino(this.position.slice(0), new Set(this.entries));
    }

    static square(size) {
      var entries, x, y;
      entries = _.flatten((function() {
        var j, ref, results;
        results = [];
        for (y = j = 0, ref = size; (0 <= ref ? j < ref : j > ref); y = 0 <= ref ? ++j : --j) {
          results.push((function() {
            var k, ref1, results1;
            results1 = [];
            for (x = k = 0, ref1 = size; (0 <= ref1 ? k < ref1 : k > ref1); x = 0 <= ref1 ? ++k : --k) {
              results1.push([x, y]);
            }
            return results1;
          })());
        }
        return results;
      })(), true);
      return new Polyomino([0, 0], entries);
    }

    this_xor(other) { // XORs and modifies this polyomino with `other`, used for reducing jigsaw pieces to polyominos
      // Doesn't care about position
      return this.entries = this.entries.xor(other.entries);
    }

    shift_offset(x, y) { // shifts the offsets of the blocks instead of the overall position
      this.entries.forEach(function(entry) {
        entry[0] += x;
        return entry[1] += y;
      });
      return this.entries.rebuild();
    }

    rotate_offset(amount) { // rotates offsets counterclockwise around the origin, amount is Piece.CCW_xx
      return this.entries = (function() {
        switch (amount) {
          case Piece.CCW_90:
            return new Set(this.entries.map(function(entry) {
              return [entry[1], -entry[0] - 1];
            }));
          case Piece.CCW_180:
            return new Set(this.entries.map(function(entry) {
              return [-entry[0] - 1, -entry[1] - 1];
            }));
          case Piece.CCW_270:
            return new Set(this.entries.map(function(entry) {
              return [-entry[1] - 1, entry[0]];
            }));
          default:
            return this.entries;
        }
      }).call(this);
    }

    rotate_around(amount, x, y) {
      this.shift_offset(-x, -y);
      this.rotate_offset(amount);
      return this.shift_offset(x, y);
    }

    reoffset() {
      var min_x, min_y;
      // Re-offset to origin
      [min_x, min_y] = [
        this.entries.min(function(a,
        b) {
          return a[0] - b[0];
        })[0],
        this.entries.min(function(a,
        b) {
          return a[1] - b[1];
        })[1]
      ];
      this.entries.forEach(function(entry) {
        entry[0] -= min_x;
        return entry[1] -= min_y;
      });
      return this.entries.rebuild();
    }

    rotate(amount) {
      this.rotate_offset(amount);
      return this.reoffset();
    }

    neighbors(point) { // returns the neighbors of a point in right, up, left, down order
      return [this.entries.contains([point[0] + 1, point[1]]) ? [point[0] + 1, point[1]] : null, this.entries.contains([point[0], point[1] - 1]) ? [point[0], point[1] - 1] : null, this.entries.contains([point[0] - 1, point[1]]) ? [point[0] - 1, point[1]] : null, this.entries.contains([point[0], point[1] + 1]) ? [point[0], point[1] + 1] : null];
    }

    reduce_unsigned(common, ustart) { // common: common number to use for edge, ustart: start of unique numbers
      var block_map;
      block_map = new Hash(_.flatten(this.entries.map(function(entry) {
        var i;
        return [
          entry,
          (function() {
            var j,
          results;
            results = [];
            for (i = j = 0; j < 4; i = ++j) {
              results.push(void 0);
            }
            return results;
          })()
        ];
      }), true));
      this.entries.forEach((entry) => {
        var i, j, len, nb, ref, results;
        ref = poly.neighbors(entry);
        results = [];
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          nb = ref[i];
          if ((nb != null) && this.entries.contains(nb)) {
            if (block_map.get(entry)[i] == null) {
              block_map.get(entry)[i] = ustart; // edges inside jigsaw get unique color that acts like glue
              block_map.get(nb)[(i + 2) % 4] = ustart;
              results.push(ustart += 1);
            } else {
              results.push(void 0);
            }
          } else {
            results.push(block_map.get(entry)[i] = common); // edges of jigsaw get color common to all edges
          }
        }
        return results;
      });
      return block_map.map(function(pair) {
        return new UnsignedBlock(pair.key.slice(0), pair.value);
      });
    }

  };
  Puzzle = class Puzzle {
    constructor(width1, height1) {
      this.width = width1;
      this.height = height1;
    }

    from_3_partition(nums) {}

    init_render(draw) {} // Renders the puzzle

  };
  EdgeMatch = class EdgeMatch extends Puzzle {
    constructor(width, height, pieces1) {
      super(width, height);
      this.pieces = pieces1;
    }

    get_piece(x, y) {
      return this.pieces[y * this.width + x];
    }

    set_piece(x, y, piece) {
      return this.pieces[y * this.width + x] = piece;
    }

    swap_pieces(x1, y1, x2, y2) { //Assumes that the piece at x1, y1 is invading the spot x2, y2
      var piece1, piece2, ref;
      piece1 = this.get_piece(x1, y1);
      piece2 = this.get_piece(x2, y2);
      piece1.position = [x2, y2];
      if (piece2 != null) {
        piece2.position = [x1, y1];
      }
      if (piece2 != null) {
        if ((ref = piece2.svg) != null) {
          ref.animate(400, '>').x(x1 + 0.5).y(y1 + 0.5);
        }
      }
      this.set_piece(x1, y1, piece2);
      return this.set_piece(x2, y2, piece1);
    }

  };
  UnsignedEdgeMatch = class UnsignedEdgeMatch extends EdgeMatch {
    constructor(width, height, pieces) {
      super(width, height, pieces);
    }

    static from_3_partition(nums) {
      var common_horz, common_vert, height, i, index, j, k, l, len, m, n, num, o, p, piece, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, s, target_sum, uem, unique, width, x, y;
      target_sum = target_sum_3_partition(nums);
      width = target_sum + 2;
      height = nums.length / 3 + 2;
      uem = new UnsignedEdgeMatch(width, height, (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = width * height; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          results.push(new UnsignedBlock([0, 0], (function() {
            var k, results1;
            results1 = [];
            for (i = k = 0; k < 4; i = ++k) {
              results1.push(void 0);
            }
            return results1;
          })()));
        }
        return results;
      })());

// Update positions
      for (y = j = 0, ref = height; (0 <= ref ? j < ref : j > ref); y = 0 <= ref ? ++j : --j) {
        for (x = k = 0, ref1 = width; (0 <= ref1 ? k < ref1 : k > ref1); x = 0 <= ref1 ? ++k : --k) {
          uem.get_piece(x, y).position = [x, y];
        }
      }
      unique = 1;
// Give the frame unique colors
      for (x = l = 0, ref2 = width; (0 <= ref2 ? l < ref2 : l > ref2); x = 0 <= ref2 ? ++l : --l) {
        uem.get_piece(x, 0).entries[Block.TOP] = unique;
        uem.get_piece(x, height - 1).entries[Block.BOTTOM] = unique + 1;
        unique += 2;
      }
      for (y = m = 0, ref3 = height; (0 <= ref3 ? m < ref3 : m > ref3); y = 0 <= ref3 ? ++m : --m) {
        uem.get_piece(0, y).entries[Block.LEFT] = unique;
        uem.get_piece(width - 1, y).entries[Block.RIGHT] = unique + 1;
        unique += 2;
      }

// Give the frame-inside matching unique colors
      for (x = n = 0, ref4 = width - 1; (0 <= ref4 ? n < ref4 : n > ref4); x = 0 <= ref4 ? ++n : --n) {
        uem.get_piece(x, 0).entries[Block.RIGHT] = unique;
        uem.get_piece(x + 1, 0).entries[Block.LEFT] = unique;
        uem.get_piece(x, height - 1).entries[Block.RIGHT] = unique + 1;
        uem.get_piece(x + 1, height - 1).entries[Block.LEFT] = unique + 1;
        unique += 2;
      }
      for (y = o = 0, ref5 = height - 1; (0 <= ref5 ? o < ref5 : o > ref5); y = 0 <= ref5 ? ++o : --o) {
        uem.get_piece(0, y).entries[Block.BOTTOM] = unique;
        uem.get_piece(0, y + 1).entries[Block.TOP] = unique;
        uem.get_piece(width - 1, y).entries[Block.BOTTOM] = unique + 1;
        uem.get_piece(width - 1, y + 1).entries[Block.TOP] = unique + 1;
        unique += 2;
      }
      common_horz = unique;
      common_vert = unique + 1;
      unique += 2;
// Give the inner frame the "glue" color
      for (x = p = 1, ref6 = width - 1; (1 <= ref6 ? p < ref6 : p > ref6); x = 1 <= ref6 ? ++p : --p) {
        uem.get_piece(x, 0).entries[Block.BOTTOM] = common_vert;
        uem.get_piece(x, height - 1).entries[Block.TOP] = common_vert;
      }
      for (y = q = 1, ref7 = height - 1; (1 <= ref7 ? q < ref7 : q > ref7); y = 1 <= ref7 ? ++q : --q) {
        uem.get_piece(0, y).entries[Block.RIGHT] = common_horz;
        uem.get_piece(width - 1, y).entries[Block.LEFT] = common_horz;
      }
      
      // Now for the filling in the pie: all the a_i gadgets
      index = 0;
      for (r = 0, len = nums.length; r < len; r++) {
        num = nums[r];
        for (i = s = 0, ref8 = num; (0 <= ref8 ? s < ref8 : s > ref8); i = 0 <= ref8 ? ++s : --s) {
          piece = uem.get_piece(modulo(index, width - 2) + 1, Math.floor(index / (width - 2)) + 1);
          piece.entries[Block.TOP] = common_vert;
          piece.entries[Block.BOTTOM] = common_vert;
          piece.entries[Block.LEFT] = i === 0 ? common_horz : unique;
          if (i !== 0) {
            unique += 1;
          }
          piece.entries[Block.RIGHT] = i === num - 1 ? common_horz : unique;
          index += 1;
        }
      }
      return uem;
    }

    init_render(draw) {
      var j, k, l, piece, ref, ref1, ref2, results, tile, x, y;
// note: 2 dots
      for (x = j = 0, ref = this.width; (0 <= ref ? j <= ref : j >= ref); x = 0 <= ref ? ++j : --j) {
        draw.line(x, 0, x, this.height).stroke({
          color: '#000',
          width: 1 / 16
        });
      }
      for (y = k = 0, ref1 = this.height; (0 <= ref1 ? k <= ref1 : k >= ref1); y = 0 <= ref1 ? ++k : --k) {
        draw.line(0, y, this.width, y).stroke({
          color: '#000',
          width: 1 / 16
        });
      }
      results = [];
      for (y = l = 0, ref2 = this.height; (0 <= ref2 ? l < ref2 : l > ref2); y = 0 <= ref2 ? ++l : --l) {
        results.push((function() {
          var m, ref3, results1;
          results1 = [];
          for (x = m = 0, ref3 = this.width; (0 <= ref3 ? m < ref3 : m > ref3); x = 0 <= ref3 ? ++m : --m) {
            piece = this.get_piece(x, y);
            if (piece != null) {
              tile = draw.ublock_tile(this.get_piece(x, y).entries).move(x + 0.5, y + 0.5);
              tile.draggable({
                minX: 0.5,
                maxX: this.width + 0.5,
                minY: 0.5,
                maxY: this.height + 0.5
              }).on('beforedrag', Block.tile_before_drag).on('dragmove', Block.tile_drag_move).on('dragend', Block.tile_drag_end);
              tile.puzzle = this;
              tile.piece = piece;
              results1.push(piece.svg = tile);
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    }

  };
  SignedEdgeMatch = class SignedEdgeMatch extends EdgeMatch {
    constructor(width, height, pieces) {
      super(width, height, pieces);
    }

  };
  JigsawPuzzle = class JigsawPuzzle extends EdgeMatch {
    constructor(width, height, pieces) {
      super(width, height, pieces);
    }

  };
  PolyominoPack = class PolyominoPack extends Puzzle {
    constructor(width, height, pieces1) {
      super(width, height);
      this.pieces = pieces1;
    }

  };
  draw = SVG(drawing);
  return render = function() {
    var j, len, num, nums, str, strs, uem;
    str = document.getElementById('3_partition').value;
    document.getElementById('bad_3_partition').innerHTML = '';
    strs = _.filter(str.split(' '), function(str) {
      return str !== ''; // JavaScript for some reason keeps the empty strings
    });
    if (strs.length === 0) {
      document.getElementById('bad_3_partition').innerHTML = "Congrats. Because you didn't enter any numbers, you just divided by 0. Catastrophe incoming...";
      return;
    }
    nums = [];
    for (j = 0, len = strs.length; j < len; j++) {
      str = strs[j];
      num = parseFloat(str);
      if (isNaN(num) || num < 1 || !Number.isInteger(num)) {
        document.getElementById('bad_3_partition').innerHTML = `${str} is not a positive integer.`;
        return;
      }
      nums.push(num);
    }
    if (!Number.isInteger(target_sum_3_partition(nums))) {
      document.getElementById('bad_3_partition').innerHTML = "The sum of the numbers must be divisible by the number of numbers divided by 3.";
      return;
    }
    uem = UnsignedEdgeMatch.from_3_partition(nums);
    draw.clear();
    draw.size(uem.width * 64, uem.height * 64);
    draw.viewbox(0, 0, uem.width, uem.height);
    return uem.init_render(draw);
  };
});

//sb = new SignedBlock [0, 0], [1, 3, -6, -7]
//jig = sb.reduce_jigsaw 7
//poly = jig.reduce_polyomino 7

//str_ = ''
//for num in block.entries
//	str_ += "#{num.toString()} "
//document.getElementById('result').innerHTML = "[#{str_}]"

//test example: [1, 5, 3, 12, 8, 19, 7, 4, 13, 4, 2, 10]
