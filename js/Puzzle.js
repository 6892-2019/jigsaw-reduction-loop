// Generated by CoffeeScript 2.3.2
(function() {
  var Block, Piece, Polyomino, SignedBlock, UnsignedBlock, block, j, len, num, ref, str_;

  Piece = class Piece {
    // Basic piece of a puzzle
    constructor(position1) { // [x, y]
      this.position = position1;
    }

    rotate() {}

  };

  Block = class Block extends Piece {
    // Stores entries in east, north, west, south order
    constructor(position, entries1) {
      super(position);
      this.entries = entries1;
    }

    rotate() {
      return this.entries.unshift(this.entries.pop());
    }

  };

  UnsignedBlock = class UnsignedBlock extends Block {
    // Positive integer entries only!
    constructor(position, entries) {
      super(position, entries);
    }

    reduce_signed(u0, u1, u2, u3) {
      // Return the 4 signed blocks that can simulate this unsigned one
      return [new SignedBlock([0, 0], [u1, this.entries[1], -this.entries[2], -u2]), new SignedBlock([1, 0], [-u3, u2, this.entries[2], -this.entries[3]]), new SignedBlock([0, 1], [-this.entries[0], -u0, u3, this.entries[3]]), new SignedBlock([1, 1], [this.entries[0], -this.entries[1], -u1, u0])];
    }

  };

  SignedBlock = class SignedBlock extends Block {
    // Positive and negative integer entries only!
    constructor(position, entries) {
      super(position, entries);
    }

  };

  Polyomino = (function() {
    class Polyomino extends Piece {
      // Stores entries as a list of offset positions
      constructor(position, entries1) {
        super(position);
        this.entries = entries1;
      }

    };

    rotate(function() {
      var entry, i, j, k, len, len1, min_x, min_y, results;
      for (i = j = 0, len = entries.length; j < len; i = ++j) {
        entry = entries[i];
        entries[i] = [entry[1], -entry[0]];
      }
      [min_x, min_y] = [
        Math.min((function() {
          var k,
        len1,
        results;
          results = [];
          for (k = 0, len1 = entries.length; k < len1; k++) {
            entry = entries[k];
            results.push(entry[0]);
          }
          return results;
        })()),
        Math.min((function() {
          var k,
        len1,
        results;
          results = [];
          for (k = 0, len1 = entries.length; k < len1; k++) {
            entry = entries[k];
            results.push(entry[1]);
          }
          return results;
        })())
      ];
      results = [];
      for (k = 0, len1 = entries.length; k < len1; k++) {
        entry = entries[k];
        entry[0] -= min_x;
        results.push(entry[1] -= min_y);
      }
      return results;
    });

    return Polyomino;

  }).call(this);

  block = new Block([0, 0], [1, 2, 3, 4]);

  block.rotate();

  console.log(...block.position);

  str_ = '';

  ref = block.entries;
  for (j = 0, len = ref.length; j < len; j++) {
    num = ref[j];
    str_ += `${num.toString()} `;
  }

  document.getElementById('result').innerHTML = `[${str_}]`;

}).call(this);
